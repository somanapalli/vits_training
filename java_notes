sept-12th/2023

java:
`````
java is an oo  programming langauge.

to develop the software.

what is software/application:

sunmicrosystem 

desktop/standalone application 

   -results are not sharable across the globe. 
   
distributed/intenet based application .

using java, we can develop both type of applications


 1995
 13 features 
 java is platform independent 
 
 
 windows
 
 .java(source code) -> developer 
 
   as well as compiler 
   
   java compiler -> whether programmer follows 
   syntaxes or not?
   
   
    compiler will generate .class file for your
	.java file. 
	
	
	.class file contains -> byte code.
	
	
	byte code: 
	
	 byte code cannot understanable by human beings.
	 
	 jvm -> java virtual machine
	 
	platform independent

   
steps to write the java program:


www.oralce.com 

download and install jdk in your machine
select the editor (notepad,notepad++,eclipse...)
write the java program 
save the java program (.java)-source code
compile the java program (.class)-byte code 
    -java compiler 
run/execute the java program 
    -jvm 
	
	
jdk,jre & jvm 

jdk stands for java development kit 
 which provides both dev environment and as well 
 as runtime environment.
 
jre stands for java runtime environment , name itself
is saying it provides only runtime environment
using this we can execute/run the java applications.


jvm stands for java virtual machine using this 
we can execute the java program .


	





java is case sensitive.

structure of the java program:

  class Welcome
  {
     public static void main(String[] args)
	 {
	  System.out.println("welcome to vits");   
	 }
  
  }
  








   
	 
	 
	 
	 
	 
	 
 
 .class 
 
 
 variablie initialization 
 
  
 <datatypename> <variablename> = <value>;
 
 
 
 int roll_no = 3131;
 
4 categories

integer

   byte,short,int,long
   
   
   -to store integer values.

 every datatype is maintaining their own 
 size and range.
 
 byte -> 1 byte (8 bits)
 range of byte datatype -> -128 to 127
 
 byte b = 128;
 
 
 -2^n-1 to 2^n-1 -1
 -2^7 to 2^7 -1
 
 -128 to 127
 
 byte 1 byte
 short 2 bytes
 
 int 4 bytes
 long 8 bytes
 
   

float - 4 bytes, double - 8bytes

   123.89;
   
float f = 6.7876786f;

double d = 6.776576576576567;


 char c = 'a';(2 bytes)
 
 
 
 



character


boolean 

  -To store logical values either true or false.
  
  
 boolean b = true; (not defined)
 boolean x = false;
 
 
 method:
 method is the place where we are writing the logic 
 which is used to perfrom some operation based 
 on the requirement.
 
 
 syntax:
 ```````
 
 [accessmodifier] <returntype> <methodname>([parms])
 {
    //logic 
 }
 
 define one method which gives sum of two numbers.
 
 void getSum()
 {
   System.out.println(5+7);   
 }
 
 
 define one method which returns your salary?
 
 double getSalary(){
 
   return 46000.00;
   
 }
   
 returntype and return value must be compatible
 with each other.
 
 
 
 
 define one method which takes two integer parameters
 and gives their multiplication?
 
    void getMultiplication(int x, int y){
	
	System.out.println(x*y);
	}


define one method which takes firstname and last name 
as parameters and returns their fullname?

       String getFullName(String fname,String lname)
	   {
	     return fname+lname;
	   }
	   
oops principles 

  class 
  object

  
class looks like 

 object:
 
  instance of class is known as object 
  
 whenever we create the object, then only memory 
 will be created.
 
 
 syntax to create the object:
 <classname> <objectname> = new <classname>();
 
 ex:
 
   Test1 obj = new Test1();
   
   whenever we create the object, memory will be 
   allocated for the non-static/instance variables which 
   we declared inside the class. 
   
   
 
 
 
 
 
 
 
 
 
 


 class Test1{
	  //instance variables
	 
	   int roll_no=3131;
	   String stname="vandhana";
	   
	   //static variables
	   static String collegeName="vits";
	  
	  //define  method 
	  //non-static or instance method
	  void displayStudentInfo(){
		   //instance area 
		  System.out.println("student rollno is: " + roll_no);
	      System.out.println("student name is: " + stname);
	      System.out.println("college name is: " + Test1.collegeName);
           
	 }
	 
	 
	  public static void main(String[] args)
	  {
		  //static area
		  Test1 obj = new Test1();
		  
		  System.out.println(obj.roll_no);
		  System.out.println(obj.stname);
		  
		  System.out.println(collegeName);
		  
		  System.out.println("===============");
		  //invoke the displayStudentInfo()
		  obj.displayStudentInfo();
		  
	  }
  
 }
 
 
 constructor:
 ````````````
 
 constructor is meant for initializing the object.
 
 system defined default constructor meant for 
 intializing the default values.
 
 user defined default constructor meant for 
 initializing our own values.
 
 rules:
 constructor should not return anything even void also.
 
 constructor name and class name must be same. 
 
sum(int x, int y)
{
}

sum()
{
}

Test1()
{
}

 
  class Test1{
	  int x;
	  String y;
	  
	  public  Test1(int x, String y ){
		  this.x=x;
		  this.y=y;
		 
	  }
	  
	  
	  public void displayValue()
	  {
		  System.out.println("x value is: " + x);
		  System.out.println("y value is: " + y);
	  }
	   
	  public static void main(String[] args)
	  {
		  
	      Test1 obj = new Test1(100,"rk");
		 
		  obj.displayValue();
	  }
	  
 }
 
 
 
 constructor chaining:
 
constructor calling is from top to bottom where as execution is from 
bottom to top.


public class Test2 {
	
	Test2(){
		//call current class single parametrized constructor
		this(4);
		System.out.println("iam from default constructor");
		
	}
	
	Test2(int x){
		//call current class double parameterized constructor
		this(10,"rk");
		System.out.println("iam from single parameterized constructor");
	}
	
	Test2(int x, String y)
	{
		System.out.println("iam from double parameterized constructor");
	}
	
	public static void main(String[] args) {
		
		Test2 obj1 = new Test2();
		//Test2 obj2 = new Test2(9);
		//Test2 obj3 = new Test2(7,"rk");
	}

}



java is object oriented programming language


   it follows oops principles
   
omg organization (object management group)-canadian organization 

 inheritance
 polymorphism 
 encapsulation 
 abstraction 
 
reusabiility

inheritance:


inheritance is the process of taking the properties from parent class to 
child class. 


//parent class 
 class Test1
 {
   public void sum(int x, int y)
   { 
      System.out.println("sum is: " +(x+y));
	}
 }

//child class 
 class Test2 extends Test1
 {
 
    public static void main(String[] args)
	{
	     Test2 obj = new Test2();
		 obj.sum();
	}
 }
 
 
 
 
 
 
 
 
 polymorphism:
 `````````````
 
 many forms. 
 
 compile time polymorphism
 runtime polymorphism
 
 
 using two concepts
 
  1.method overloading - compiletime polymorphism
  2.method overriding  - runtime polymorphism
  
  
  method overloading:
  
    
	  method name is same 
	  but signature is different 
	  
	  signature:
	    no.of parameters
		type of parmaeters
		order of parmaeters
		
		
 sum(int x, int y)
 {
 }
 
 sum(float x, float y)
 {
 }
 
 sum(double x, double y)
 {
 }
 
 
 sum(4,5);
 sum(5.6f,4.5f)
 sum(8.9,6.7)
 

readiblity of the program gets increased.



example:


public class Test6 {

	public void sum(int x, int y) {
		System.out.println("integer sum is: " +(x+y));
	}
	
	public void sum(float x, float y)
	{
		System.out.println("float sum is: " +(x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum is: " +(x+y));
	}
	
	
	
	
	public static void main(String[] args) {
		
		Test6 obj;//object declaration 
		obj = new Test6();//object referencing
		
		obj.sum(4, 5);
		obj.sum(8.7f,5.6f);
		obj.sum(8.9,5.6);
	}

}








method overriding:

 method name is same
 but logic/body is different from parent class to child class.
 
 
 class Parent{
 marriage()
 {
   //logic 1
 }
 }
 
 class Child extends Parent{
 
  marriage()
  {
   //logic 2
  }
  
 }
 
 

//child class
public class Test4 extends Test3 {

	@Override
	public void sum(int x, int y)
	{
		System.out.println("substraction is: : " + (x-y));
	}
	public static void main(String[] args) {
		
		
		//case1 :valid: Test4 obj1 = new Test4();
		
		//case2: Test3 obj2 = new Test3();
		
	  Test3 obj3;
	  obj3= new Test4();
	    
	  obj3.sum(4, 5);
	    //case 4: Test4 obj4 = new Test3();
	    
	    
	    
	}
	
	
}

encapsulation:
``````````````

the process of wrapping up of variables and methods into a single unit. 
class is the best example for encapsulation.

 data hiding 
 
class Test1
{

}

class contains variables 

variables must be private
for each and every variable we require public setter methods and 
public getter methods.

setter methods -> to set the values into an object
getter methods -> to get the values from the object. 



Student.java:
`````````````
public class Student
{
	//variables
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}

}

Test7.java:
````````````

public class Test7 {

	public static void main(String[] args) {
		
		Student obj = new Student();
		
		obj.setStid(100);
		
		obj.setStname("rama");
		
		System.out.println("student id is: " + obj.getStid());
		System.out.println("student name is: " + obj.getStname());
		
	}
}

abstraction:
```````````

   abstraction is the process of retrieving the essential details 
   by hiding the logic(implementation details)
   
   
   ->by using two concepts
   
   1.abstract class
   2.interface
   
   
abstract class:

   abstract class Test1{
   
     public abstract void sum(int x, int y);
	 
   }
   
   
   0 to 100%
   
   
  Test8.java:
``````````````

//abstract class where specification is available
public abstract class Test8 {
	
public abstract void sum(int x, int  y);
	

}


Test9.java:
```````````
  
//implementation class cum child class cum business logic class 
public class Test9 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));

	}

}

Test10.java:
```````````

public class Test10 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction is : " +(x-y));
	}

	public static void main(String[] args) {
		
		
		Test8 obj1 = new Test9();
		Test8 obj2 = new Test10();
		
		obj1.sum(2, 3);
		
		obj2.sum(2, 3);
		
		
		
		
	}
}

   
   
   
   
   
interface:
``````````
   interface contains only abstract methods 
   
  syntax:
  
     interface <interfacename>
	 {
	 
	    //constants
		//abstract methods 
	 }
   
   
   by default interface variables are public static final 
   by default interface methods are public abstract 
   
   
 Bank.java:
````````````
 
public interface Bank {

	double rateOfInterest();
}

SBI.java:
``````````

public class SBI implements Bank{

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 5.5;
	}

}


HDFC.java:
``````````

public class HDFC implements Bank {

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

Test12.java:
```````````````

//execution logic class
public class Test12 {
	
	public static void main(String[] args) {
		
		
		Bank obj = new SBI();
		Bank obj1 = new HDFC();
		
		System.out.println("SBI rate of interest is: " + obj.rateOfInterest());
		System.out.println("HDFC rate of interst is : " + obj1.rateOfInterest());
		
	}

}


 super keyword:
 
 suepr is the java reserved keyword.
 
 
  super refering parent class properties.
  
  

to refer the parent class variable 
syntax:
  super.<parentclassvariablename>
  
  
  Test3.java:
  ```````````
  //parent class
public class Test3 {

	 int x=100;
}

Test4.java:
````````````
//child class
public class Test4 extends Test3 {

	 int x = 200;
	 
	 public void display()
	 {
		 System.out.println(x);
		 System.out.println(super.x);
		 
		 
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.display();
	}

}



super at method:


   super.<parentclassmethod>();

Test3.java:
```````````
//parent class
public class Test3 {

	public void sum(int x, int y)
	{
		System.out.println("integer sum is: " + (x+y));
	}
}

Test4.java:
```````````

//child class
public class Test4 extends Test3 {

	 @Override
	 public void sum(int x, int y)
	 {
		System.out.println("integer substraction is: " +(x-y));
		
		//invoke parent class sum method using super keyword
		
		super.sum(6, 5);
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.sum(3, 4);
	}

}


super at constructor level:
 
  constructor should not be inherited.
  
  writing the super() is optional to invoke parent class 
  default constructor.
  
  
  writing the super(..) is mandatory to invoke parent class 
  paramerterized constructor(s).
  
   
  Test3.java:
```````````
//parent class
public class Test3 {

	public Test3()
	{
		System.out.println(" default constructor-parent class");
	}
}

Test4.java:
```````````
  //child class
public class Test4 extends Test3 {

	public Test4()
	{
		//invoking parent class default constructor
		//super();
		System.out.println("default constructor -child class");
	}
	
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		
	}

}

   
sept 14th/day-3
```````````````

package:
````````
    collection of classes, interfaces, and sub packages
	
	

package com.vits;

public class Test1 {
	
 public void sum(int x, int y)
	{
		System.out.println("sum is : "  + (x+y));
	}
	
	

}


package com.vits;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj  = new Test1();
		
		obj.sum(3,4);
		
	}

}



package com.rsr;
import com.vits.*;
public class Test2 {
	
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.sum(3, 4);
	}

}









i want to perform the sum of two numbers 

 how can i pass dynamic data?
 
  package com.runtimeargs;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		String s1= args[0];
		String s2 = args[1];
		
		int x = Integer.parseInt(s1);
		int y = Integer.parseInt(s2);
		int z = x+y;
		
		System.out.println("result is: " + z);
	}

}


example:
````````
package com.loops;

public class Test1 {
	
	public static void main(String[] args) {
		
		int x[]= {100,200,300,400,500};
	
		for(int i=0;i<x.length;i++)
		{
			System.out.println(x[i]);
		}
		
		System.out.println("====================");
		
		for(int y:x)
		{
			System.out.println(y);
		}
		
	}

}



if,ifelse,ifelseif,swtichcase,for,while,dowhile,foreach.

daily 3 questions 

  
exception handling:
```````````````````

   errors
   
      compiletime errors-> compiler
	  runtime errors ->exception 
	  if you make any mistake at your logic->jvm 
	  
	  enter first number: 4
	  enter second number: abc
	  
	  result: 8
	  
	 ...
	 ...  int x = 100/0;
	 ...
	 ...
	 ...
	 1000 lines of code 




	 
	1.program terminated abnormally 
    	
	2.we will get system error messages which are not understanable by 
	  end user  which is not recommended .
	  
	
to resolve above 2 issues, we have to handle the exceptions.

 how can we handle the exceptions in java?
    
	     using some java reserved keywords
		 
		 
		 1.try
		 
		 2.catch
		 
		 3.finally
		 
		 4.throws
		 
		 5.throws
		 
	try
catch
 
 

package com.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		int x=100;
		int y = 0;
		try {
		 int z = x/y;
		 System.out.println("division is: " + z);	
		}
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as denominator");
		}
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
	
	}

}

  
 example:
 `````````
 package com.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
	   
		System.out.println("enter first number");
		
		int x = s.nextInt();
		
		System.out.println("enter second number");
		
		int y = s.nextInt();
		
		int z = x/y;
		
		System.out.println("division is : " + z);
		}
		
	
		catch(Exception  re)
		{
			
			if(re instanceof ArithmeticException)
			{
				System.out.println("dont enter zero as denominator");
			}
			
			if(re instanceof InputMismatchException)
			{
				System.out.println("please enter only numeric values");
			}
		}
		finally {
			System.out.println("finally block executed always");
		}  
		
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
	
		
	}

}














throws is a java reserved keyword which gives an indication to 
the calling function to keep the called function under try and 
catch block.


Test2.java:
```````````
package com.exceptions;
//called program
public class Test2 {
	
	//called function 
	public void division() throws ArithmeticException
	{
		int z = 100/0;
		
		System.out.println("division is : " +z);
	}

}

Test3.java:
````````````
package com.exceptions;
//calling program 
public class Test3 {
   //calling function
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("dont enter zero as denominator");
		}
	
		
	}
}

throw:
```````
throw is a java reserved keywords which is used to 
throw an exception explicitly.

 thorwing an exceptioin is nothing but creating an object.
 
 syntax:
 
   throw new <exceptionclassname>();
   
   throw new ArithmeticException();
   

Test4.java:
`````````````
package com.exceptions;

public class Test4 {
	
	public void checkProduct(int weight) {
		
		if(weight>100) {
			System.out.println("product is valid");
			
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ip)
			{
				System.out.println("product weight must be greater than 100kgs");
			}
		}
	}
	
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
package com.exceptions;

public class InvalidProductException extends Exception{
}


cfw:
    
	int x[]={100,200};
	
	arrays are not following proper datastructure.
	in ararys, for every operation we have to write the 
	logic manually.
	
	
	
	
	only we are allowed to store homogenious data.
	
	   using arrays, it is not possible
	   
	   using collections , it is possible.
	   
	because of drawbacks of arrays we are moving to 
collection framework .

	
array size is fixed in nature.



to add both homogenious and heterogenous objects into a single 
object.

 to work this cfw, we are going to use 
 some predefined interfaces and predefined classes. 
 
 available in java.util package.
 
 
                       Collection 
					   
					      there is no implementation class 
						  
					   
					       
 List
                       Queue
                                               Set
                                              SortedSet
 etc..
 
 interface List extends Collection 
 {
 }
 
->it is accepting both homogenious objects and heterogenous 
  objects
->insertion order is preserved

->duplicates are allowed

->null insertion is also possible.



  List l = new List();
  
  ->ArrayList
  ->LinkedList
  ->Vector
  ->Stack 
  
  
class ArrayList implements List extends Collection 
{
}

package com.collections;

import java.util.LinkedList;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object of ArrayList
		
		LinkedList al = new LinkedList();
		
		System.out.println(al);
		al.add("rama");
		al.add(10);
		al.add(true);
		al.add(8.9);
		al.add(8.7f);
		al.add(10);
		al.add(null);
		
		
		System.out.println(al.get(0));
		System.out.println("size is : " + al.size());
		
		System.out.println(al.remove());
		System.out.println(al.remove(0));
		System.out.println(al.size());
		
		System.out.println(al);
		
		al.add(0,"rama");
		System.out.println(al);
		
	}

}

java.util package 

         Collection 
 List
              Queue
                            Set
                            SortedSet
 

ArrayList

  ->if our requirement is accessing, then we will go 
    for ArrayList
	
    RandomAccess 
	
	
LinkedList
  if my requirement is insertion/deletion/updation 
     ->internally doubley linkedlist algorithm 
	 ->node based elemenets got inserted
	 
	 

Set:
````
->it allows both homogenious and heterogenous objects
->insertion order is not preserved
->duplicates are not allowed
->null insertion is possible but only for one time


  ->HashSet
  ->LinkedHashSet
  
  

class HashSet implements Set extends Collection 
{


}

   Set s = new HashSet();
   
   






  ArrayList al = new ArrayList();
    al.add(Integer.valueOf(8));
	
	
	int
	Integer
	
	
	jdk 1.5 version onwards 
	
	primitive values -> object types(autoboxing)
	object types -> primitive types (autounboxing)
	
	
package com.collections;

import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		//creating the object for HashSet
		
		LinkedHashSet hs = new LinkedHashSet();
		
		hs.add(67);
		hs.add(7.8f);
		hs.add(null);
		hs.add(67);
		hs.add(true);
		hs.add(null);
		
	
		//foreach loop
		
		for(Object o:hs)
		{
			System.out.println(o);
		}
		
		
	}
}
	
	
Test2.java:
``````````
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet hs = new HashSet();
		
		Student st1 = new Student(100,"rk");
		Student st2  = new Student(101,"navin");
		Student st3 = new Student(102,"vandana");
		
		
		hs.add(st1);
		hs.add(st2);
		hs.add(st3);
		
		for(Object o:hs)
		{
			System.out.println(o);
		}
		
		
	}
}

//Student.java:

package com.collections;

public class Student {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	

}


----------------
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<>();
		
		
		for(int i=1;i<=10;i++) {
			hs.add(i);
		}

		
		
		
        for(Integer x:hs) {
        	
        	
        	if(x%2==0) {
        		System.out.println(x);
        	}
        }
	}
}


---------------------
Student.java:

package com.collections;

public class Student {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	

}

Test2.java:
```````````
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Student> hs = new HashSet<>();
		
		
		
		hs.add(new Student(100,"Rk"));
		hs.add(new Student(101,"navin"));
		hs.add(new Student(102,"vits"));
		

		for(Student s: hs) {
			
			if(s.getStname().startsWith("v"))
			{
				System.out.println(s.getStname());
			}
		}
		
		
	}
}

hierarchy of TreeSet:
```````````````````````
class TreeSet implements  SortedSet extends Set extends Colletion 
{
}
 
    
->it doesn't allows heterogenous elements 
  it accepts only homogenious elements.
  
->we can predict the order of the data 
  default natural sorting order is ascending
  
->duplicate objects are not allowed
->null insertion is not possible.


SortedSet s = new TreeSet();


Test4.java:
`````````````
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<Integer> ts = new TreeSet<>();
		
		ts.add(8);
		ts.add(89);
		ts.add(6);
		ts.add(765);
		
		System.out.println(ts);
		
		
	}
}

--------------
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<String> ts = new TreeSet<>();
		
		ts.add("rk");
		ts.add("abc");
		ts.add("navin");
		ts.add("vits");
		
		
		System.out.println(ts);
		
		
	}
}

note:
if we want to add any objects to the SortedSet , it should be
homogenious and aswell as Comaprable objects.

Integer
String 


Student.java:
````````````````
package com.collections;

public class Student implements Comparable<Student> {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	@Override
	public int compareTo(Student o) {
		
	   if(this.getStid()>o.getStid())
	   {
		   return -9;
	   }
	   else if(this.getStid()<o.getStid())
	   {
		   return 9;
	   }
		  
	   else
	   {
		   return 0;
	   }
		
	}
	

}

Test4.java:
````````````
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<>();
		
		ts.add(new Student(10,"rk"));
		ts.add(new Student(7,"abc"));
		ts.add(new Student(89,"pranay"));
		
		
		
		System.out.println(ts);
		
		
	}
}






Comparable is meant for getting the data in 
natural sorting order.



package com.collections;

public class Student implements Comparable<Student> {
	
	private Integer stid;
	private String stname;
	
	
	
	
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	public Student(Integer stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	@Override
	public int compareTo(Student o) {
		  
		//return -this.getStid().compareTo(o.getStid());
		
		return o.getStname().compareTo(this.getStname());
	}
	

}










cursors in java:

 
  Iterator
  ListIterator
  

package com.collections;

import java.util.HashSet;
import java.util.Iterator;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<Integer>();
		
		for(int i=1;i<=10;i++)
		{
			hs.add(i);
			
		}
		
		Iterator<Integer> itr = hs.iterator();
		
		while(itr.hasNext())
		{
			Integer x = itr.next();
			if(x%2!=0)
			{
				itr.remove();
			}
		}
		System.out.println(hs);
		
		
		
	}
}

Test6.java:
``````````
package com.collections;

import java.util.ArrayList;
import java.util.Collections;

public class Test6 {
	
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		al.add(8);
		al.add(6);
		al.add(98);
		al.add(67);
		al.add(5);
		
		//Collections.sort(al);
		
		Collections.sort(al,new MyComparator());
		
		System.out.println(al);
		
	}

}

MyComparator.java:
````````````````````
package com.collections;

import java.util.Comparator;

public class MyComparator implements Comparator<Integer> {

	@Override
	public int compare(Integer o1, Integer o2) {
		
		
		/*
		 * if(o1>o2) { return -3; } else if(o1<o2) { return 3;
		 * 
		 * } else { return 0; }
		 */
		
		return -o1.compareTo(o2);
	}

}



Map:
````

   (key,value) pairs
   
   key-object
   value -object
   
   Map 
      interface 
	  
   interface SortedMap extends Map{
   }
   
     put(key,value);
	 
   
   
	  
package com.collections;

import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Test7 {
	
	public static void main(String[] args) {
		
		TreeMap hm = new TreeMap(new MyComparator());
		
		hm.put(100, "rama");
		hm.put(78, "vits");
		hm.put(45, "xyz");
		hm.put(100, "rk");
		hm.put(101, "rk");
		
		
		
		Set<Map.Entry<Integer,String>> s = hm.entrySet();
		
		for(Map.Entry m:s)
		{
			System.out.println(m.getKey() + " "  + m.getValue());
		}
		
		
	}

}
	  
day-5(16th sep,2023)
````````````````````

multithreading

overview of database(ddl,dml,drl)-oracle

jdbc 

java8 features


multithreading:
````````````````
->multiple threads

thread->task


Test1.java:
`````````````
package com.multithreading;

public class Test1 extends Thread {

	public void run() {
		for (int i = 1; i <= 10; i++) {
			System.out.println(Thread.currentThread().getName() + "->" + i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException ie) {
				System.out.println(ie);
			}
		}
	}

}

Test2.java:
``````````````
package com.multithreading;

public class Test2 extends Thread {

	public void run() {
		for (int i = 1; i <= 10; i++) {
			System.out.println(Thread.currentThread().getName() + "->" + i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException ie) {
				System.out.println(ie);
			}
		}
	}
}

Test3.java:
```````````
package com.multithreading;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		Test1 t1 = new Test1();
		t1.setName("rk");
		t1.start();
		
		Test2 t2 = new Test2();
		t2.setName("navin");
		t2.start();
	}

}






































       
  
  
  
  

	
	
	


