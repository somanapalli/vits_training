sept-12th/2023

java:
`````
java is an oo  programming langauge.

to develop the software.

what is software/application:

sunmicrosystem 

desktop/standalone application 

   -results are not sharable across the globe. 
   
distributed/intenet based application .

using java, we can develop both type of applications


 1995
 13 features 
 java is platform independent 
 
 
 windows
 
 .java(source code) -> developer 
 
   as well as compiler 
   
   java compiler -> whether programmer follows 
   syntaxes or not?
   
   
    compiler will generate .class file for your
	.java file. 
	
	
	.class file contains -> byte code.
	
	
	byte code: 
	
	 byte code cannot understanable by human beings.
	 
	 jvm -> java virtual machine
	 
	platform independent

   
steps to write the java program:


www.oralce.com 

download and install jdk in your machine
select the editor (notepad,notepad++,eclipse...)
write the java program 
save the java program (.java)-source code
compile the java program (.class)-byte code 
    -java compiler 
run/execute the java program 
    -jvm 
	
	
jdk,jre & jvm 

jdk stands for java development kit 
 which provides both dev environment and as well 
 as runtime environment.
 
jre stands for java runtime environment , name itself
is saying it provides only runtime environment
using this we can execute/run the java applications.


jvm stands for java virtual machine using this 
we can execute the java program .


	





java is case sensitive.

structure of the java program:

  class Welcome
  {
     public static void main(String[] args)
	 {
	  System.out.println("welcome to vits");   
	 }
  
  }
  








   
	 
	 
	 
	 
	 
	 
 
 .class 
 
 
 variablie initialization 
 
  
 <datatypename> <variablename> = <value>;
 
 
 
 int roll_no = 3131;
 
4 categories

integer

   byte,short,int,long
   
   
   -to store integer values.

 every datatype is maintaining their own 
 size and range.
 
 byte -> 1 byte (8 bits)
 range of byte datatype -> -128 to 127
 
 byte b = 128;
 
 
 -2^n-1 to 2^n-1 -1
 -2^7 to 2^7 -1
 
 -128 to 127
 
 byte 1 byte
 short 2 bytes
 
 int 4 bytes
 long 8 bytes
 
   

float - 4 bytes, double - 8bytes

   123.89;
   
float f = 6.7876786f;

double d = 6.776576576576567;


 char c = 'a';(2 bytes)
 
 
 
 



character


boolean 

  -To store logical values either true or false.
  
  
 boolean b = true; (not defined)
 boolean x = false;
 
 
 method:
 method is the place where we are writing the logic 
 which is used to perfrom some operation based 
 on the requirement.
 
 
 syntax:
 ```````
 
 [accessmodifier] <returntype> <methodname>([parms])
 {
    //logic 
 }
 
 define one method which gives sum of two numbers.
 
 void getSum()
 {
   System.out.println(5+7);   
 }
 
 
 define one method which returns your salary?
 
 double getSalary(){
 
   return 46000.00;
   
 }
   
 returntype and return value must be compatible
 with each other.
 
 
 
 
 define one method which takes two integer parameters
 and gives their multiplication?
 
    void getMultiplication(int x, int y){
	
	System.out.println(x*y);
	}


define one method which takes firstname and last name 
as parameters and returns their fullname?

       String getFullName(String fname,String lname)
	   {
	     return fname+lname;
	   }
	   
oops principles 

  class 
  object

  
class looks like 

 object:
 
  instance of class is known as object 
  
 whenever we create the object, then only memory 
 will be created.
 
 
 syntax to create the object:
 <classname> <objectname> = new <classname>();
 
 ex:
 
   Test1 obj = new Test1();
   
   whenever we create the object, memory will be 
   allocated for the non-static/instance variables which 
   we declared inside the class. 
   
   
 
 
 
 
 
 
 
 
 
 


 class Test1{
	  //instance variables
	 
	   int roll_no=3131;
	   String stname="vandhana";
	   
	   //static variables
	   static String collegeName="vits";
	  
	  //define  method 
	  //non-static or instance method
	  void displayStudentInfo(){
		   //instance area 
		  System.out.println("student rollno is: " + roll_no);
	      System.out.println("student name is: " + stname);
	      System.out.println("college name is: " + Test1.collegeName);
           
	 }
	 
	 
	  public static void main(String[] args)
	  {
		  //static area
		  Test1 obj = new Test1();
		  
		  System.out.println(obj.roll_no);
		  System.out.println(obj.stname);
		  
		  System.out.println(collegeName);
		  
		  System.out.println("===============");
		  //invoke the displayStudentInfo()
		  obj.displayStudentInfo();
		  
	  }
  
 }
 
 
 constructor:
 ````````````
 
 constructor is meant for initializing the object.
 
 system defined default constructor meant for 
 intializing the default values.
 
 user defined default constructor meant for 
 initializing our own values.
 
 rules:
 constructor should not return anything even void also.
 
 constructor name and class name must be same. 
 
sum(int x, int y)
{
}

sum()
{
}

Test1()
{
}

 
  class Test1{
	  int x;
	  String y;
	  
	  public  Test1(int x, String y ){
		  this.x=x;
		  this.y=y;
		 
	  }
	  
	  
	  public void displayValue()
	  {
		  System.out.println("x value is: " + x);
		  System.out.println("y value is: " + y);
	  }
	   
	  public static void main(String[] args)
	  {
		  
	      Test1 obj = new Test1(100,"rk");
		 
		  obj.displayValue();
	  }
	  
 }
 
 
 
 constructor chaining:
 
constructor calling is from top to bottom where as execution is from 
bottom to top.


public class Test2 {
	
	Test2(){
		//call current class single parametrized constructor
		this(4);
		System.out.println("iam from default constructor");
		
	}
	
	Test2(int x){
		//call current class double parameterized constructor
		this(10,"rk");
		System.out.println("iam from single parameterized constructor");
	}
	
	Test2(int x, String y)
	{
		System.out.println("iam from double parameterized constructor");
	}
	
	public static void main(String[] args) {
		
		Test2 obj1 = new Test2();
		//Test2 obj2 = new Test2(9);
		//Test2 obj3 = new Test2(7,"rk");
	}

}



java is object oriented programming language


   it follows oops principles
   
omg organization (object management group)-canadian organization 

 inheritance
 polymorphism 
 encapsulation 
 abstraction 
 
reusabiility

inheritance:


inheritance is the process of taking the properties from parent class to 
child class. 


//parent class 
 class Test1
 {
   public void sum(int x, int y)
   { 
      System.out.println("sum is: " +(x+y));
	}
 }

//child class 
 class Test2 extends Test1
 {
 
    public static void main(String[] args)
	{
	     Test2 obj = new Test2();
		 obj.sum();
	}
 }
 
 
 
 
 
 
 
 
 polymorphism:
 `````````````
 
 many forms. 
 
 compile time polymorphism
 runtime polymorphism
 
 
 using two concepts
 
  1.method overloading - compiletime polymorphism
  2.method overriding  - runtime polymorphism
  
  
  method overloading:
  
    
	  method name is same 
	  but signature is different 
	  
	  signature:
	    no.of parameters
		type of parmaeters
		order of parmaeters
		
		
 sum(int x, int y)
 {
 }
 
 sum(float x, float y)
 {
 }
 
 sum(double x, double y)
 {
 }
 
 
 sum(4,5);
 sum(5.6f,4.5f)
 sum(8.9,6.7)
 

readiblity of the program gets increased.



example:


public class Test6 {

	public void sum(int x, int y) {
		System.out.println("integer sum is: " +(x+y));
	}
	
	public void sum(float x, float y)
	{
		System.out.println("float sum is: " +(x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum is: " +(x+y));
	}
	
	
	
	
	public static void main(String[] args) {
		
		Test6 obj;//object declaration 
		obj = new Test6();//object referencing
		
		obj.sum(4, 5);
		obj.sum(8.7f,5.6f);
		obj.sum(8.9,5.6);
	}

}








method overriding:

 method name is same
 but logic/body is different from parent class to child class.
 
 
 class Parent{
 marriage()
 {
   //logic 1
 }
 }
 
 class Child extends Parent{
 
  marriage()
  {
   //logic 2
  }
  
 }
 
 

//child class
public class Test4 extends Test3 {

	@Override
	public void sum(int x, int y)
	{
		System.out.println("substraction is: : " + (x-y));
	}
	public static void main(String[] args) {
		
		
		//case1 :valid: Test4 obj1 = new Test4();
		
		//case2: Test3 obj2 = new Test3();
		
	  Test3 obj3;
	  obj3= new Test4();
	    
	  obj3.sum(4, 5);
	    //case 4: Test4 obj4 = new Test3();
	    
	    
	    
	}
	
	
}

encapsulation:
``````````````

the process of wrapping up of variables and methods into a single unit. 
class is the best example for encapsulation.

 data hiding 
 
class Test1
{

}

class contains variables 

variables must be private
for each and every variable we require public setter methods and 
public getter methods.

setter methods -> to set the values into an object
getter methods -> to get the values from the object. 



Student.java:
`````````````
public class Student
{
	//variables
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}

}

Test7.java:
````````````

public class Test7 {

	public static void main(String[] args) {
		
		Student obj = new Student();
		
		obj.setStid(100);
		
		obj.setStname("rama");
		
		System.out.println("student id is: " + obj.getStid());
		System.out.println("student name is: " + obj.getStname());
		
	}
}

abstraction:
```````````

   abstraction is the process of retrieving the essential details 
   by hiding the logic(implementation details)
   
   
   ->by using two concepts
   
   1.abstract class
   2.interface
   
   
abstract class:

   abstract class Test1{
   
     public abstract void sum(int x, int y);
	 
   }
   
   
   0 to 100%
   
   
  Test8.java:
``````````````

//abstract class where specification is available
public abstract class Test8 {
	
public abstract void sum(int x, int  y);
	

}


Test9.java:
```````````
  
//implementation class cum child class cum business logic class 
public class Test9 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));

	}

}

Test10.java:
```````````

public class Test10 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction is : " +(x-y));
	}

	public static void main(String[] args) {
		
		
		Test8 obj1 = new Test9();
		Test8 obj2 = new Test10();
		
		obj1.sum(2, 3);
		
		obj2.sum(2, 3);
		
		
		
		
	}
}

   
   
   
   
   
interface:
``````````
   interface contains only abstract methods 
   
  syntax:
  
     interface <interfacename>
	 {
	 
	    //constants
		//abstract methods 
	 }
   
   
   by default interface variables are public static final 
   by default interface methods are public abstract 
   
   
 Bank.java:
````````````
 
public interface Bank {

	double rateOfInterest();
}

SBI.java:
``````````

public class SBI implements Bank{

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 5.5;
	}

}


HDFC.java:
``````````

public class HDFC implements Bank {

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

Test12.java:
```````````````

//execution logic class
public class Test12 {
	
	public static void main(String[] args) {
		
		
		Bank obj = new SBI();
		Bank obj1 = new HDFC();
		
		System.out.println("SBI rate of interest is: " + obj.rateOfInterest());
		System.out.println("HDFC rate of interst is : " + obj1.rateOfInterest());
		
	}

}


 super keyword:
 
 suepr is the java reserved keyword.
 
 
  super refering parent class properties.
  
  

to refer the parent class variable 
syntax:
  super.<parentclassvariablename>
  
  
  Test3.java:
  ```````````
  //parent class
public class Test3 {

	 int x=100;
}

Test4.java:
````````````
//child class
public class Test4 extends Test3 {

	 int x = 200;
	 
	 public void display()
	 {
		 System.out.println(x);
		 System.out.println(super.x);
		 
		 
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.display();
	}

}



super at method:


   super.<parentclassmethod>();

Test3.java:
```````````
//parent class
public class Test3 {

	public void sum(int x, int y)
	{
		System.out.println("integer sum is: " + (x+y));
	}
}

Test4.java:
```````````

//child class
public class Test4 extends Test3 {

	 @Override
	 public void sum(int x, int y)
	 {
		System.out.println("integer substraction is: " +(x-y));
		
		//invoke parent class sum method using super keyword
		
		super.sum(6, 5);
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.sum(3, 4);
	}

}


super at constructor level:
 
  constructor should not be inherited.
  
  writing the super() is optional to invoke parent class 
  default constructor.
  
  
  writing the super(..) is mandatory to invoke parent class 
  paramerterized constructor(s).
  
   
  Test3.java:
```````````
//parent class
public class Test3 {

	public Test3()
	{
		System.out.println(" default constructor-parent class");
	}
}

Test4.java:
```````````
  //child class
public class Test4 extends Test3 {

	public Test4()
	{
		//invoking parent class default constructor
		//super();
		System.out.println("default constructor -child class");
	}
	
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		
	}

}

   
sept 14th/day-3
```````````````

package:
````````
    collection of classes, interfaces, and sub packages
	
	

package com.vits;

public class Test1 {
	
 public void sum(int x, int y)
	{
		System.out.println("sum is : "  + (x+y));
	}
	
	

}


package com.vits;

public class Test2 {
	
	public static void main(String[] args) {
		
		Test1 obj  = new Test1();
		
		obj.sum(3,4);
		
	}

}



package com.rsr;
import com.vits.*;
public class Test2 {
	
	
	public static void main(String[] args) {
		
		Test1 obj = new Test1();
		
		obj.sum(3, 4);
	}

}









i want to perform the sum of two numbers 

 how can i pass dynamic data?
 
  package com.runtimeargs;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		String s1= args[0];
		String s2 = args[1];
		
		int x = Integer.parseInt(s1);
		int y = Integer.parseInt(s2);
		int z = x+y;
		
		System.out.println("result is: " + z);
	}

}


example:
````````
package com.loops;

public class Test1 {
	
	public static void main(String[] args) {
		
		int x[]= {100,200,300,400,500};
	
		for(int i=0;i<x.length;i++)
		{
			System.out.println(x[i]);
		}
		
		System.out.println("====================");
		
		for(int y:x)
		{
			System.out.println(y);
		}
		
	}

}



if,ifelse,ifelseif,swtichcase,for,while,dowhile,foreach.

daily 3 questions 

  
exception handling:
```````````````````

   errors
   
      compiletime errors-> compiler
	  runtime errors ->exception 
	  if you make any mistake at your logic->jvm 
	  
	  enter first number: 4
	  enter second number: abc
	  
	  result: 8
	  
	 ...
	 ...  int x = 100/0;
	 ...
	 ...
	 ...
	 1000 lines of code 




	 
	1.program terminated abnormally 
    	
	2.we will get system error messages which are not understanable by 
	  end user  which is not recommended .
	  
	
to resolve above 2 issues, we have to handle the exceptions.

 how can we handle the exceptions in java?
    
	     using some java reserved keywords
		 
		 
		 1.try
		 
		 2.catch
		 
		 3.finally
		 
		 4.throws
		 
		 5.throws
		 
	try
catch
 
 

package com.exceptions;

public class Test1 {
	
	public static void main(String[] args) {
		int x=100;
		int y = 0;
		try {
		 int z = x/y;
		 System.out.println("division is: " + z);	
		}
		
		catch(ArithmeticException ae)
		{
			System.out.println("don't enter zero as denominator");
		}
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
	
	}

}

  
 example:
 `````````
 package com.exceptions;

import java.util.InputMismatchException;
import java.util.Scanner;

public class Test1 {
	
	public static void main(String[] args) {
		try {
		Scanner s = new Scanner(System.in);
		
	   
		System.out.println("enter first number");
		
		int x = s.nextInt();
		
		System.out.println("enter second number");
		
		int y = s.nextInt();
		
		int z = x/y;
		
		System.out.println("division is : " + z);
		}
		
	
		catch(Exception  re)
		{
			
			if(re instanceof ArithmeticException)
			{
				System.out.println("dont enter zero as denominator");
			}
			
			if(re instanceof InputMismatchException)
			{
				System.out.println("please enter only numeric values");
			}
		}
		finally {
			System.out.println("finally block executed always");
		}  
		
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
		System.out.println("rest statements executed");
	
		
	}

}














throws is a java reserved keyword which gives an indication to 
the calling function to keep the called function under try and 
catch block.


Test2.java:
```````````
package com.exceptions;
//called program
public class Test2 {
	
	//called function 
	public void division() throws ArithmeticException
	{
		int z = 100/0;
		
		System.out.println("division is : " +z);
	}

}

Test3.java:
````````````
package com.exceptions;
//calling program 
public class Test3 {
   //calling function
	public static void main(String[] args) {
		
		Test2 obj = new Test2();
		try {
		obj.division();
		}
		catch(ArithmeticException ae)
		{
			System.out.println("dont enter zero as denominator");
		}
	
		
	}
}

throw:
```````
throw is a java reserved keywords which is used to 
throw an exception explicitly.

 thorwing an exceptioin is nothing but creating an object.
 
 syntax:
 
   throw new <exceptionclassname>();
   
   throw new ArithmeticException();
   

Test4.java:
`````````````
package com.exceptions;

public class Test4 {
	
	public void checkProduct(int weight) {
		
		if(weight>100) {
			System.out.println("product is valid");
			
		}
		else
		{
			try {
			throw new InvalidProductException();
			}
			catch(InvalidProductException ip)
			{
				System.out.println("product weight must be greater than 100kgs");
			}
		}
	}
	
	
	public static void main(String[] args) {
		
		Test4 obj = new Test4();
		obj.checkProduct(20);
	}

}

InvalidProductException.java:
``````````````````````````````
package com.exceptions;

public class InvalidProductException extends Exception{
}


cfw:
    
	int x[]={100,200};
	
	arrays are not following proper datastructure.
	in ararys, for every operation we have to write the 
	logic manually.
	
	
	
	
	only we are allowed to store homogenious data.
	
	   using arrays, it is not possible
	   
	   using collections , it is possible.
	   
	because of drawbacks of arrays we are moving to 
collection framework .

	
array size is fixed in nature.



to add both homogenious and heterogenous objects into a single 
object.

 to work this cfw, we are going to use 
 some predefined interfaces and predefined classes. 
 
 available in java.util package.
 
 
                       Collection 
					   
					      there is no implementation class 
						  
					   
					       
 List
                       Queue
                                               Set
                                              SortedSet
 etc..
 
 interface List extends Collection 
 {
 }
 
->it is accepting both homogenious objects and heterogenous 
  objects
->insertion order is preserved

->duplicates are allowed

->null insertion is also possible.



  List l = new List();
  
  ->ArrayList
  ->LinkedList
  ->Vector
  ->Stack 
  
  
class ArrayList implements List extends Collection 
{
}

package com.collections;

import java.util.LinkedList;

public class Test1 {
	
	public static void main(String[] args) {
		
		
		//create the object of ArrayList
		
		LinkedList al = new LinkedList();
		
		System.out.println(al);
		al.add("rama");
		al.add(10);
		al.add(true);
		al.add(8.9);
		al.add(8.7f);
		al.add(10);
		al.add(null);
		
		
		System.out.println(al.get(0));
		System.out.println("size is : " + al.size());
		
		System.out.println(al.remove());
		System.out.println(al.remove(0));
		System.out.println(al.size());
		
		System.out.println(al);
		
		al.add(0,"rama");
		System.out.println(al);
		
	}

}

java.util package 

         Collection 
 List
              Queue
                            Set
                            SortedSet
 

ArrayList

  ->if our requirement is accessing, then we will go 
    for ArrayList
	
    RandomAccess 
	
	
LinkedList
  if my requirement is insertion/deletion/updation 
     ->internally doubley linkedlist algorithm 
	 ->node based elemenets got inserted
	 
	 

Set:
````
->it allows both homogenious and heterogenous objects
->insertion order is not preserved
->duplicates are not allowed
->null insertion is possible but only for one time


  ->HashSet
  ->LinkedHashSet
  
  

class HashSet implements Set extends Collection 
{


}

   Set s = new HashSet();
   
   






  ArrayList al = new ArrayList();
    al.add(Integer.valueOf(8));
	
	
	int
	Integer
	
	
	jdk 1.5 version onwards 
	
	primitive values -> object types(autoboxing)
	object types -> primitive types (autounboxing)
	
	
package com.collections;

import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		//creating the object for HashSet
		
		LinkedHashSet hs = new LinkedHashSet();
		
		hs.add(67);
		hs.add(7.8f);
		hs.add(null);
		hs.add(67);
		hs.add(true);
		hs.add(null);
		
	
		//foreach loop
		
		for(Object o:hs)
		{
			System.out.println(o);
		}
		
		
	}
}
	
	
Test2.java:
``````````
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet hs = new HashSet();
		
		Student st1 = new Student(100,"rk");
		Student st2  = new Student(101,"navin");
		Student st3 = new Student(102,"vandana");
		
		
		hs.add(st1);
		hs.add(st2);
		hs.add(st3);
		
		for(Object o:hs)
		{
			System.out.println(o);
		}
		
		
	}
}

//Student.java:

package com.collections;

public class Student {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	

}


----------------
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<>();
		
		
		for(int i=1;i<=10;i++) {
			hs.add(i);
		}

		
		
		
        for(Integer x:hs) {
        	
        	
        	if(x%2==0) {
        		System.out.println(x);
        	}
        }
	}
}


---------------------
Student.java:

package com.collections;

public class Student {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	

}

Test2.java:
```````````
package com.collections;

import java.util.HashSet;
import java.util.LinkedHashSet;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Student> hs = new HashSet<>();
		
		
		
		hs.add(new Student(100,"Rk"));
		hs.add(new Student(101,"navin"));
		hs.add(new Student(102,"vits"));
		

		for(Student s: hs) {
			
			if(s.getStname().startsWith("v"))
			{
				System.out.println(s.getStname());
			}
		}
		
		
	}
}

hierarchy of TreeSet:
```````````````````````
class TreeSet implements  SortedSet extends Set extends Colletion 
{
}
 
    
->it doesn't allows heterogenous elements 
  it accepts only homogenious elements.
  
->we can predict the order of the data 
  default natural sorting order is ascending
  
->duplicate objects are not allowed
->null insertion is not possible.


SortedSet s = new TreeSet();


Test4.java:
`````````````
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<Integer> ts = new TreeSet<>();
		
		ts.add(8);
		ts.add(89);
		ts.add(6);
		ts.add(765);
		
		System.out.println(ts);
		
		
	}
}

--------------
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<String> ts = new TreeSet<>();
		
		ts.add("rk");
		ts.add("abc");
		ts.add("navin");
		ts.add("vits");
		
		
		System.out.println(ts);
		
		
	}
}

note:
if we want to add any objects to the SortedSet , it should be
homogenious and aswell as Comaprable objects.

Integer
String 


Student.java:
````````````````
package com.collections;

public class Student implements Comparable<Student> {
	
	private int stid;
	private String stname;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	
	public Student()
	{
	
	}
	
	public String toString()
	{
		return stid + " " +stname;
	}
	@Override
	public int compareTo(Student o) {
		
	   if(this.getStid()>o.getStid())
	   {
		   return -9;
	   }
	   else if(this.getStid()<o.getStid())
	   {
		   return 9;
	   }
		  
	   else
	   {
		   return 0;
	   }
		
	}
	

}

Test4.java:
````````````
package com.collections;

import java.util.TreeSet;

public class Test4 {

	
	public static void main(String[] args) {
		
		TreeSet<Student> ts = new TreeSet<>();
		
		ts.add(new Student(10,"rk"));
		ts.add(new Student(7,"abc"));
		ts.add(new Student(89,"pranay"));
		
		
		
		System.out.println(ts);
		
		
	}
}






Comparable is meant for getting the data in 
natural sorting order.



package com.collections;

public class Student implements Comparable<Student> {
	
	private Integer stid;
	private String stname;
	
	
	
	
	public Integer getStid() {
		return stid;
	}
	public void setStid(Integer stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public String toString()
	{
		return stid + " " +stname;
	}
	
	
	public Student(Integer stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	@Override
	public int compareTo(Student o) {
		  
		//return -this.getStid().compareTo(o.getStid());
		
		return o.getStname().compareTo(this.getStname());
	}
	

}










cursors in java:

 
  Iterator
  ListIterator
  

package com.collections;

import java.util.HashSet;
import java.util.Iterator;

public class Test2 {

	
	public static void main(String[] args) {
		
		HashSet<Integer> hs = new HashSet<Integer>();
		
		for(int i=1;i<=10;i++)
		{
			hs.add(i);
			
		}
		
		Iterator<Integer> itr = hs.iterator();
		
		while(itr.hasNext())
		{
			Integer x = itr.next();
			if(x%2!=0)
			{
				itr.remove();
			}
		}
		System.out.println(hs);
		
		
		
	}
}

Test6.java:
``````````
package com.collections;

import java.util.ArrayList;
import java.util.Collections;

public class Test6 {
	
	public static void main(String[] args) {
		
		ArrayList<Integer> al = new ArrayList<Integer>();
		
		al.add(8);
		al.add(6);
		al.add(98);
		al.add(67);
		al.add(5);
		
		//Collections.sort(al);
		
		Collections.sort(al,new MyComparator());
		
		System.out.println(al);
		
	}

}

MyComparator.java:
````````````````````
package com.collections;

import java.util.Comparator;

public class MyComparator implements Comparator<Integer> {

	@Override
	public int compare(Integer o1, Integer o2) {
		
		
		/*
		 * if(o1>o2) { return -3; } else if(o1<o2) { return 3;
		 * 
		 * } else { return 0; }
		 */
		
		return -o1.compareTo(o2);
	}

}



Map:
````

   (key,value) pairs
   
   key-object
   value -object
   
   Map 
      interface 
	  
   interface SortedMap extends Map{
   }
   
     put(key,value);
	 
   
   
	  
package com.collections;

import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

public class Test7 {
	
	public static void main(String[] args) {
		
		TreeMap hm = new TreeMap(new MyComparator());
		
		hm.put(100, "rama");
		hm.put(78, "vits");
		hm.put(45, "xyz");
		hm.put(100, "rk");
		hm.put(101, "rk");
		
		
		
		Set<Map.Entry<Integer,String>> s = hm.entrySet();
		
		for(Map.Entry m:s)
		{
			System.out.println(m.getKey() + " "  + m.getValue());
		}
		
		
	}

}
	  
day-5(16th sep,2023)
````````````````````

multithreading

overview of database(ddl,dml,drl)-oracle

jdbc 

java8 features


multithreading:
````````````````
->multiple threads

thread->task


Test1.java:
`````````````
package com.multithreading;

public class Test1 extends Thread {

	public void run() {
		for (int i = 1; i <= 10; i++) {
			System.out.println(Thread.currentThread().getName() + "->" + i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException ie) {
				System.out.println(ie);
			}
		}
	}

}

Test2.java:
``````````````
package com.multithreading;

public class Test2 extends Thread {

	public void run() {
		for (int i = 1; i <= 10; i++) {
			System.out.println(Thread.currentThread().getName() + "->" + i);
			try {
				Thread.sleep(1000);
			} catch (InterruptedException ie) {
				System.out.println(ie);
			}
		}
	}
}

Test3.java:
```````````
package com.multithreading;

public class Test3 {
	
	public static void main(String[] args) {
		
		
		Test1 t1 = new Test1();
		t1.setName("rk");
		t1.start();
		
		Test2 t2 = new Test2();
		t2.setName("navin");
		t2.start();
	}

}





https://github.com/somanapalli/vits_training


steps to write the jdbc program


package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {
	
	
	public static void main(String[] args) {
		
		try {
		//load the driver class
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		System.out.println("driver class loaded");
		
		//get the connection 
		
		Connection con = DriverManager.
				getConnection("jdbc:oracle:thin:@localhost:1521:xe", 
						"system",
						"system");
		
		System.out.println("i got the connection ");
		
		//create the object for Statement interface to send the sql queries
		
		 Statement st = con.createStatement();
		 
		 String query = "insert into student values(101,'vits')";
		 
		 //process the query 
		 
		 int x = st.executeUpdate(query);
		 
		 System.out.println(x + " row(s) inserted");
		 
		 //closing the connection 
		 con.close();
		 
		}
		
		catch(Exception e) {
			System.out.println(e);
		}
		
	}

}


//

package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test2 {
	
	public static void main(String[] args) throws Exception {
		
		//load the driver class
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");
		
		Statement st = con.createStatement();
		
		int x = st.executeUpdate("delete from student where stid=101");
		
		
		System.out.println(x + "row(s) deleted");
		
		con.close();
		
		
	}

}


--------------------------
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class Test2 {
	
	public static void main(String[] args) throws Exception {
		
		//load the driver class
		
		Class.forName("oracle.jdbc.driver.OracleDriver");
		
		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe","system","system");
		
		Statement st = con.createStatement();
		
		ResultSet rs = st.executeQuery("select * from student");
		
		while(rs.next())
		{
			System.out.println(rs.getInt(1) + " " + rs.getString(2));
		}
		
		
		con.close();
		
		
	}

}






-----------------------------
package com.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.util.Scanner;

public class Test2 {

	public static void main(String[] args) throws Exception {

		// load the driver class

		Class.forName("oracle.jdbc.driver.OracleDriver");

		Connection con = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:xe", "system", "system");

		PreparedStatement ps= con.prepareStatement("insert into student values(?,?)");

		Scanner s= new Scanner(System.in);
		
		System.out.println("enter the student id");
		
		int x = s.nextInt();
		
		System.out.println("enter the student name");
		
		String y= s.next();
		
		ps.setInt(1,x);
		ps.setString(2, y);
		
		
		int z = ps.executeUpdate();
		
		System.out.println(z+ "row(s) inserted");
		
		
		
		
		
	}
}

differnce between Statement and PreparedStatement?














String url = "jdbc:mysql://localhost:3306/your_database_name";
        String username = "your_username";
        String password = "your_password";

        try {
            // Step 1: Load the MySQL JDBC driver
            Class.forName("com.mysql.cj.jdbc.Driver");


com.mysql.cj.jdbc.Driver

jdbc:mysql://localhost:3306/sys



package com.vits.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {
	
	public static void main(String[] args) throws Exception {
		
		
		//load the driver class
		
		Class.forName("com.mysql.cj.jdbc.Driver");
		
		System.out.println("driver class loaded");
		//obtain the connection 
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys", "root", "root");
		
		System.out.println("i got the connection ");
		
		Statement st = con.createStatement();
		
		int x = st.executeUpdate("insert into emp values(400,'vaishnavi')");
		System.out.println(x + "row(s) inserted");
		
		//close the connection 
		con.close();
		
		
	}

}





https://github.com/somanapalli/vits_training

 
WelcomeServlet.java:
````````````````````
package com.vits;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class WelcomeServlet extends HttpServlet {
	
	public void init()
	{
		System.out.println("init method got executed only once");
	}

	//business logic
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		System.out.println("executed many times");
		
	}
	
	//overriding destroy()
	public void destroy()
	{
		System.out.println("destroy got executed");
	}
	
	

}

web.xml:(src/main/web-app/WEB-INF/web.xml)
``````````

<?xml version="1.0" encoding="UTF-8"?>
<web-app>

	<servlet>
		<servlet-name>rk</servlet-name>
		<servlet-class>com.vits.WelcomeServlet</servlet-class>

	</servlet>

	<servlet-mapping>

		<servlet-name>rk</servlet-name>
		<url-pattern>/display</url-pattern>


	</servlet-mapping>



</web-app>



index.html:
````````````
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

  <form method="post" action="getMessage">
   
    Enter First Number: <input type="text" name="t1"/><br/>
    Enter Second Number: <input type="text" name="t2"/><br/>
    
    <input type="submit" value="sum"/>
    
  </form>

</body>
</html>

DisplayServlet.java:
```````````````````````
package com.vits;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class DisplayServlet
 */
@WebServlet("/getMessage")
public class DisplayServlet extends HttpServlet {
	
	public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		
		  int fno = Integer.parseInt(request.getParameter("t1"));
		  int sno = Integer.parseInt(request.getParameter("t2"));
		  
		  int result = fno + sno;
		  
		  response.getWriter().println("<h1> The sum is: " +result + " </h1>");
	}

	
}


servlet communication
```````````````````````

   RequestDispatcher -interface 
   
   HttpServletRequest we have one method is there
     
	 RequestDispatcher rd = request.getRequestDispatcher();
	 
	 rd.forward(request,response)
	    source servlet -> destination resource 
		
		
	 rd.include();
	     it is used to include the response of destination 
		 resource .
		 
		 
   







index.html:
````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
 
 <%--scriptlet tag --%>
<%

  int x = Integer.parseInt(request.getParameter("t1"));
  int y = Integer.parseInt(request.getParameter("t2"));
  int z = x+y;
  //out.println("the sum is: " + z);

%>

<%= "the sum is: " +z %>

<%--declarative tag --%>
<%!
  public int square(int x)
  {
	return x*x;
  }

%>
 
</body>
</html>

index.jsp:
```````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
 
 <%--scriptlet tag --%>
<%

  int x = Integer.parseInt(request.getParameter("t1"));
  int y = Integer.parseInt(request.getParameter("t2"));
  int z = x+y;
  //out.println("the sum is: " + z);

%>

<%= "the sum is: " +z %>

<%--declarative tag --%>
<%!
  public int square(int x)
  {
	return x*x;
  }

%>
 
</body>
</html>


maven:
build automation tool

<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.vits</groupId>
  <artifactId>jdbc_mysql_maven</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>jdbc_mysql_maven</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.target>1.8</maven.compiler.target>
    <maven.compiler.source>1.8</maven.compiler.source>
  </properties>

  <dependencies>
  
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>3.8.1</version>
      <scope>test</scope>
    </dependency>
    
    <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.33</version>
</dependency>
    
  </dependencies>
</project>

Test1.java:
```````````
package com.vits;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class Test1 {

	public static void main(String[] args) throws Exception {
		// load the driver class

		Class.forName("com.mysql.cj.jdbc.Driver");

		System.out.println("driver class loaded");
		// obtain the connection
		Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/sys", "root", "root");
		System.out.println("i got the connection ");
		Statement st = con.createStatement();
		int x = st.executeUpdate("insert into emp values(500,'vandana')");
		System.out.println(x + "row(s) inserted");
		// close the connection
		con.close();

	}

}

maven goals:

maven build...

goal: clean 
goal: install
goal: clean install

for core java project 

maven archetype: quickstart

for java web projects:

maven archetype: web-app

https://github.com/somanapalli/vits_training

spring core module example:
```````````````````````````
pom.xml:
````````
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.vits</groupId>
	<artifactId>springcore_demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>springcore_demo</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>


		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>

		<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>6.0.12</version>
		</dependency>



	</dependencies>
</project>

Student.java:
```````````````
package com.vits;
//pojo class or java class or bean class
public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public Student(int stid, String stname) {
		super();
		this.stid = stid;
		this.stname = stname;
	}
	@Override
	public String toString() {
		return "Student [stid=" + stid + ", stname=" + stname + "]";
	}
	
	public Student()
	{
		
	}

}

App.java:
`````````
package com.vits;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        
       ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
       
       Student stu= context.getBean(Student.class);
       
       stu.setStid(100);
       stu.setStname("Rama");
       
       System.out.println(stu.getStid());
       System.out.println(stu.getStname());
    }
}

applicationContext.xml:
``````````````````````
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="stu" class="com.vits.Student">
  
  
  </bean>



</beans>

---------------------------------------------------------------
how to inject reference type values:
````````````````````````````````````
Student.java:
`````````````
package com.sopra.beans;

public class Student {
	
	private Address address;

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}
	
	public Student()
	{
		
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}
	

}


Address.java:
`````````````
package com.sopra.beans;

public class Address {
	
	private String cityName;
	private String stateName;
	private String countryName;
	
	
	
	public String getCityName() {
		return cityName;
	}
	public void setCityName(String cityName) {
		this.cityName = cityName;
	}
	public String getStateName() {
		return stateName;
	}
	public void setStateName(String stateName) {
		this.stateName = stateName;
	}
	public String getCountryName() {
		return countryName;
	}
	public void setCountryName(String countryName) {
		this.countryName = countryName;
	}
	
	
	public Address()
	{
		
	}
	@Override
	public String toString() {
		return "Address [cityName=" + cityName + ", stateName=" + stateName + ", countryName=" + countryName + "]";
	}

}

springcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


   <bean id="stu" class="com.sopra.beans.Student">
   
       <property name="address">
       
          <ref bean="add"/>
          
       </property>  
       
    </bean>
    
    <bean id="add" class="com.sopra.beans.Address">
    
       <property name="cityName" value="Hyd"/>
       <property name="stateName" value="Tel"/>
       <property name="countryName" value="India"/>
    
    </bean>


</beans>

Test.java:
```````````
package com.sopra.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
		ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
		
		Student stu = (Student)context.getBean("stu");
		
		System.out.println("city name is : " + stu.getAddress().getCityName());
		System.out.println("state name is: " + stu.getAddress().getStateName());		
		System.out.println("country name is: " + stu.getAddress().getCountryName());
	}

}



how to inject collection type values (list,set,map):
````````````````````````````````````````````````````
Student.java:
``````````````
package com.sopra.beans;

import java.util.List;

public class Student {
	
	private int stid;
	private String stname;
	private List<String> subjects;
	
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	public List<String> getSubjects() {
		return subjects;
	}
	public void setSubjects(List<String> subjects) {
		this.subjects = subjects;
	}
	@Override
	public String toString() {
		return "Student [stid=" + stid + ", stname=" + stname + ", subjects=" + subjects + "]";
	}
	
	
	public Student()
	{
		
	}
	
}


springcontext.xml:
`````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


   <bean id="stu" class="com.sopra.beans.Student">
   
     <property name="stid" value="100"/>
     <property name="stname" value="Ram"/>
     <property name="subjects">
         <list>
            <value>english</value>
            <value>science</value>
            <value>Hindhi</value>
         
         </list>
     
     </property>
   
   </bean>
</beans>

Test.java:
````````````
package com.sopra.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
		ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
		
		Student stu = (Student)context.getBean("stu");
		
		System.out.println(stu);
	}

}


assignments:
```````````````
inject collection type values (set & map)


  -how to inject reference type values
  -how to inject collection type values (list)
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
autowiring:
```````````
Autowiring feature of spring framework enables you to 
inject the object dependency implicitly. 


It internally uses setter or constructor injection


note:
if we want to achieve autowiring we have to use 
autowire attribute for a bean element.


<bean id="stu" class="com.vits.Student" autowire=""/>
possible values:
                 byName
				 byType
				    setter injection 
					
				 Constructor
				    
				 
				 
if autowire=byName

springcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


   <bean id="stu" class="com.sopra.beans.Student" autowire="byName"/>
  
    
    <bean id="address" class="com.sopra.beans.Address">
    
       <property name="cityName" value="Hyd"/>
       <property name="stateName" value="Tel"/>
       <property name="countryName" value="India"/>
    
    </bean>


</beans>

Student.java:
``````````````
package com.sopra.beans;

public class Student {
	
	private Address address;

	public Address getAddress() {
		return address;
	}

	public void setAddress(Address address) {
		this.address = address;
	}
	
	public Student()
	{
		
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}
	

}


note:
`````
when we are using either autowire attribute values are byName or byType internally setter injection will happen.

if we use autowire attribute value as constructor internally it uses byType only but constructor  injection will happen.


springcontext.xml:
``````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


   <bean id="stu" class="com.sopra.beans.Student" autowire="constructor"/>
  
    
    <bean class="com.sopra.beans.Address">
    
       <property name="cityName" value="Hyd"/>
       <property name="stateName" value="Tel"/>
       <property name="countryName" value="India"/>
    
    </bean>


</beans>


annotation based wiring:
`````````````````````````
So instead of using XML to describe a bean wiring, 
you can move the bean configuration into the component class
itself by using annotations on the relevant class, method, or field declaration.


in case of annotation based wiring autowire attribute is not required
for a bean element.

we have to add @autowired annotation in the java bean class.

we no need to maintain any setter,or constructor for a bean class.

note:
````
by default spring container could not recognize these annotations , to recognize
we have to add one xml element in spring configuration file
 <context:annotation-config/>
 
note:
````
to make it execute this , we have to add one more jar spring-aop 


Student.java:
``````````````
package com.sopra.beans;

import org.springframework.beans.factory.annotation.Autowired;

public class Student {
	
	@Autowired
	private Address address;

	public Student()
	{
		
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}
	

}

springcontext.xml:
``````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

  <context:annotation-config></context:annotation-config>
   <bean id="stu" class="com.sopra.beans.Student"/>
  
    
    <bean class="com.sopra.beans.Address">
    
       <property name="cityName" value="Hyd"/>
       <property name="stateName" value="Tel"/>
       <property name="countryName" value="India"/>
    
    </bean>


</beans>

Test.java:
``````````
package com.sopra.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
		ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
		
		Student stu = (Student)context.getBean("stu");
		System.out.println(stu);
	}

}



 
 
autodisovery:
``````````````
Autodiscovery feature frees us from writing all bean declarations
and bean autowirings.

Note:
`````
this feature can be enabled by adding one xml element i.e.

<context:component-scan base-package=""/>


@Component annotation:
``````````````````````
@Component is an annotation that allows Spring to automatically detect 
our custom beans. In other words, without having to write any explicit code,
Spring will: Scan our application for classes annotated with @Component.
 
 Instantiate them and inject any specified dependencies into them. 
 Inject them wherever needed.


Student.java:
`````````````
package com.sopra.beans;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class Student {
	
	@Autowired
	private Address address;

	public Student()
	{
		
	}

	@Override
	public String toString() {
		return "Student [address=" + address + "]";
	}
	

}

springcontext.xml:
``````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

  <context:component-scan base-package="com.sopra.beans"></context:component-scan>
  
    
    <bean class="com.sopra.beans.Address">
    
       <property name="cityName" value="Hyd"/>
       <property name="stateName" value="Tel"/>
       <property name="countryName" value="India"/>
    
    </bean>


</beans>

Test.java:
```````````
package com.sopra.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
		ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
		
		Student stu = (Student)context.getBean("student");
		System.out.println(stu);
	}

}

  

 -autowiring (byName,byType,constructor)
 -annotation based wiring(@autowired)
 -autodiscovery(@Component)
 @Qualifier annotation
````````````````````

The @Qualifier annotation is used to resolve the autowiring conflict, 
when there are multiple beans of same type.


College.java:
`````````````
package com.sopra.beans;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class College {
	
	@Autowired
	@Qualifier("stu2")
	private Student student;

	@Override
	public String toString() {
		return "College [student=" + student + "]";
	}
	
	public College()
	{
		
	}
	

}


Student.java:
`````````````
package com.sopra.beans;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	
   public Student()
   {
	   
   }
@Override
public String toString() {
	return "Student [stid=" + stid + ", stname=" + stname + "]";
}
   
   
}


Test.java:
```````````
package com.sopra.beans;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test {
	
	public static void main(String[] args) {
		
		
		ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
		College col = (College)context.getBean("college");
		System.out.println(col);
		
	}

}

springcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

 <context:annotation-config></context:annotation-config>
  
 <bean id="college" class="com.sopra.beans.College">
      
     
 </bean>
 
 <bean id="stu1" class="com.sopra.beans.Student">
 
    <property name="stid" value="100"/>
    <property name="stname" value="ram"/>
 </bean>
 
 <bean id="stu2" class="com.sopra.beans.Student">
 
    <property name="stid" value="200"/>
    <property name="stname" value="nandini"/>
 </bean>
 
 


</beans>


java based configuration in spring:
``````````````````````````````````
Java-based configuration option enables you to write most of your Spring 
configuration without XML but with the help of few Java-based annotations

@Configuration

the class which is annotated with @Configuration it represents it contains configurable information.


Annotating a class with the @Configuration indicates that the class can be  used by the Spring IoC container as a source of bean definitions. 


The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context.



Student.java:
`````````````
package com.sopra;

public class Student {
	
	private int stid;
	private String stname;
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}
	
	public Student()
	{
		
	}

}

MyConfig.java:
``````````````
package com.sopra;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MyConfig {
	
	@Bean("stu")
	public Student getStudent()
	{
		return new Student();
	}
	

}


App.java:
``````````
package com.sopra;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
       
    	ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
    	Student stu = (Student)context.getBean("stu");
    	stu.setStid(100);
    	stu.setStname("ram");
    	
    	System.out.println("student id: " + stu.getStid());
    	System.out.println("student name: " + stu.getStname());
    	
    }
}

       
spring jdbc module:
````````````````````

purpose:

  to implement persistence/database logic 
  
  jdbc:
  
     load,connection,statement/PrepareStatement,process the query,close the connection
	 

JdbcTemplate


                dao class 
		 
                |
				
 				JdbcTemplate
				
				|
				
				DataSource(Interface)
				
				|
				DriverManagerDataSource
				
				  -driverClassName
				  -url
				  -username
				  -password
				  
				  

springcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

  
<context:component-scan base-package="com.sopra"></context:component-scan>
  
  
  <bean id="dao" class="com.sopra.dao.EmployeeDao">
  
     <property name="jdbcTemplate">
	       <ref bean="template"/>
	 </property>
  </bean>
  <bean id="template" class="org.springframework.jdbc.core.JdbcTemplate">
  
     <property name="dataSource" ref="ds"/>
 
  </bean>
  
  <bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
     
       <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
       <property name="url" value="jdbc:mysql://localhost:3306/sys/>
       <property name="username" value="root"/>
       <property name="password" value="root"/>
  
  </bean>

</beans>

Employee.java:
````````````````
package com.sopra.beans;

public class Employee {
	
	private int empid;
	private String firstName;
	private String lastName;
	
	
	
	public int getEmpid() {
		return empid;
	}
	public void setEmpid(int empid) {
		this.empid = empid;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	public Employee(int empid, String firstName, String lastName) {
		super();
		this.empid = empid;
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public Employee() {
		super();
	}
	@Override
	public String toString() {
		return "Employee [empid=" + empid + ", firstName=" + firstName + ", lastName=" + lastName + "]";
	}
	
	

}

EmployeeDao.java:
`````````````````
package com.sopra.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import com.sopra.beans.Employee;

@Component("dao")
public class EmployeeDao {
	
	@Autowired
	private JdbcTemplate jdbcTemplate;

	

	
	
	public int saveEmployee(Employee e)
	{
		
		String sql = "insert into employee values(?,?,?)";
		
		return jdbcTemplate.update(sql, e.getEmpid(),e.getFirstName(),e.getLastName());
	}
	
	//update,delete,select query,list of rows
	
	public Employee read(int id)
	{
		String sql = "select * from employee where id=?";
		EmployeeRowMapper rowmapper = new EmployeeRowMapper();
		
		return jdbcTemplate.queryForObject(sql, rowmapper,id);
	}
	
	
	public List<Employee> findAll()
	{
		String sql = "select * From employee";
		EmployeeRowMapper rowmapper = new EmployeeRowMapper();
		return jdbcTemplate.query(sql, rowmapper);
		
	}
	

}

App.java:
`````````
package com.sopra.beans;

import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.sopra.dao.EmployeeDao;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
      ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
      EmployeeDao dao = (EmployeeDao)context.getBean("dao");
      
      /*Employee emp = new Employee();
      emp.setEmpid(101);
      emp.setFirstName("nandini");
      emp.setLastName("jain");
      
      int x = dao.saveEmployee(emp);
      System.out.println(x + "row(s) inserted");*/
      
     /* Employee emp = dao.read(101);
      
      System.out.println("employee id is: " + emp.getEmpid());
      System.out.println("employee first name is: " + emp.getFirstName());
      System.out.println("employee last name is: " + emp.getLastName());
      */
      
      List<Employee> emps = dao.findAll();
      
      for(Employee e: emps)
      {
    	  System.out.println(e.getEmpid() + " " + e.getFirstName() + " " + e.getLastName());
      }
    	
    }
}

EmployeeRowMapper.java:
````````````````````````
package com.sopra.dao;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.jdbc.core.RowMapper;

import com.sopra.beans.Employee;

public class EmployeeRowMapper implements RowMapper<Employee> {

	public Employee mapRow(ResultSet rs, int rowNum) throws SQLException {
		
		
		Employee emp = new Employee();
		emp.setEmpid(rs.getInt(1));
		emp.setFirstName(rs.getString(2));
		emp.setLastName(rs.getString(3));
		return emp;
	}

}


spring web mvc module:
``````````````````````
using this module, we are able to develop web applications.

flow:
`````
->explained daigram



1.create maven project by chooseing web-app archetype
2.right click on the project -> go to properties -> target runtime -> add server
3.open pom.xml and add spring web mvc dependecy
4.configure the DispatcherServlet class in web.xml file
5.create controller class under src/main/java under one package(com.sopra.controller)
  make sure controller class must be annotated with @Controller annotation.
 
6.we configure view resolver class in spring configuration file
  (InternalResourceViewResolver), 
  note: spring configuration file must be followed one naming conventions
        <servlet-name>-servlet.xml
        ex: dispatcher-servlet.xml	
  
7.place the view page inside one location(WEB-INF/views/display.jsp)
8.run the application on top of server and pass the correct url so that
  our view page will be rendered.
  

HelloController.java:
`````````````````````
package com.sopra.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class HelloController {
	
	@RequestMapping("/hello")
	public ModelAndView hello()
	{
		
		ModelAndView mv = new ModelAndView();
		
		//setting the view name
		 mv.setViewName("hello");
		    
		return mv;
		
	}

}

web.xml:
````````
<!DOCTYPE web-app PUBLIC
 "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
 "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>

  <servlet>
  
     <servlet-name>spring</servlet-name>
     <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  </servlet>
  
  <servlet-mapping>
  
      <servlet-name>spring</servlet-name>
      <url-pattern>/</url-pattern>
  </servlet-mapping>
</web-app>


spring-servlet.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

  
<context:component-scan base-package="com.sopra"></context:component-scan>
  
  <bean id="view" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
  
    <property name="prefix">
    
       <value>/WEB-INF/jsp/</value>
    
    </property>
    
    <property name="suffix">
       
       <value>.jsp</value>
    
    </property>
  
  
  </bean>
  

</beans>


hello.jsp:
`````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring web mvc</h1>
</body>
</html>

note:
`````
don't forget to add the server to the spring web application.

   ->right click on project -> click on properties -> add target runtime
   ->add the server.
   
   
   
how to add the data to ModelAndView object:
```````````````````````````````````````````
HelloController.java:
````````````````````
package com.sopra.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class HelloController {
	
	@RequestMapping("/hello")
	public ModelAndView hello()
	{
		
		ModelAndView mv = new ModelAndView();
		
		mv.addObject("stid",100);
		mv.addObject("stname","ram");
		mv.addObject("staddress","hyd");
		
		
		
		//setting the view name
		 mv.setViewName("hello");
		    
		return mv;
		
	}

}


hello.jsp:
``````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring web mvc</h1><br/>
Student id: ${stid}<br/>
Student name: ${stname} <br/>
Student address: ${staddress}

</body>
</html>



how to add the java object to ModelAndView and make it 
displayed in view page:
````````````````````````````````````````````````````````````````````````````````
HelloController.java:
`````````````````````
package com.sopra.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import com.sopra.beans.Student;

@Controller
public class HelloController {
	
	@RequestMapping("/hello")
	public ModelAndView hello()
	{
		
		ModelAndView mv = new ModelAndView();
		
		Student stu = new Student();
		
		stu.setStid(100);
		stu.setStname("Ram");
		
		
		mv.addObject("student", stu);
		
		
		//setting the view name
		 mv.setViewName("hello");
		    
		return mv;
		
	}

}

hello.jsp:
```````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring web mvc</h1><br/>
Student Information: <br/>
${student}
</body>
</html>

how to add the List of java objects to ModelAndView and displayed in view page:
```````````````````````````````````````````````````````````````````````````````
HelloController.java:
``````````````````````

package com.sopra.controller;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import com.sopra.beans.Student;

@Controller
public class HelloController {
	
	@RequestMapping("/hello")
	public ModelAndView hello()
	{
		List<Student> students = new ArrayList<Student>();
		
		
		ModelAndView mv = new ModelAndView();
		
		Student stu1 = new Student();
		stu1.setStid(100);
		stu1.setStname("Ram");
		
		
		Student stu2 = new Student();
		stu2.setStid(200);
		stu2.setStname("sopra");
		
		
		students.add(stu1);
		students.add(stu2);
		
		
		mv.addObject("students",students);
		
		
		//setting the view name
		 mv.setViewName("hello");
		    
		return mv;
		
	}

}


hello.jsp:
```````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
<h1>welcome to spring web mvc</h1><br/>
Student Information: <br/>
${students}
</body>
</html>


how to send the data from view to controller and then controller to view:
```````````````````````````````````````````````````````````````````````````
RegistrationController.java:
```````````````````````````
package com.sopra.controllers;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import com.sopra.beans.Student;

@Controller
public class RegistrationController {
	
	@RequestMapping("/showreg")
	public ModelAndView showRegistrationPage()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("userReg");
		return mv;
		
	}
	
	@RequestMapping(value="/registerUser",method = RequestMethod.POST)
	public ModelAndView registerStudent(HttpServletRequest request,HttpServletResponse response)
	{
		
		String stid = request.getParameter("stid");
		String firstName = request.getParameter("firstName");
		String lastName = request.getParameter("lastName");
		
		Student stu = new Student();
		stu.setStid(Integer.parseInt(stid));
		stu.setFirstName(firstName);
		stu.setLastName(lastName);
		
		ModelAndView mv = new ModelAndView();
		mv.addObject("stu", stu);
		mv.setViewName("success");
		
		return mv;
		
		
	}
	
	
	

}

Student.java:
`````````````
package com.sopra.beans;

public class Student {
	
	private int stid;
	private String firstName;
	private String lastName;
	
	public Student()
	{
		
	}

	public int getStid() {
		return stid;
	}

	public void setStid(int stid) {
		this.stid = stid;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return "Student [stid=" + stid + ", firstName=" + firstName + ", lastName=" + lastName + "]";
	}
	
	

}

userReg.jsp:
`````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>

  <h2>Registration page</h2>
  <form action="registerUser" method="post">
  
     <pre>
      Enter Student Id: <input type="text" name="stid"/><br/>
      Enter Student FirstName: <input type="text" name="firstName"/><br/>
      Enter Student LastName: <input type="text" name="lastName"/><br/>
      <input type="submit" value="register"/>
      
     
     </pre>
  
  </form>

</body>
</html>

success.jsp:
`````````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
Students Records are: <br/>
${stu}
</body>
</html>


 
  assignment:
  ```````````
    on top of this application apply spring jdbc module to store
	student's data in the corresponding student table of db.
	

RegistrationController.java:
````````````````````````````
package com.sopra.controllers;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import com.sopra.beans.Student;
import com.sopra.dao.StudentDao;

@Controller
public class RegistrationController {
	
	
	@Autowired
	private StudentDao dao;

	@RequestMapping("/showreg")
	public ModelAndView showRegistrationPage()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("userReg");
		return mv;
		
	}
	
	/*1st approach
	 
	 * @RequestMapping(value="/registerUser",method = RequestMethod.POST)
	public ModelAndView registerStudent(HttpServletRequest request,HttpServletResponse response)
	{
		
		String stid = request.getParameter("stid");
		String firstName = request.getParameter("firstName");
		String lastName = request.getParameter("lastName");
		
		Student stu = new Student();
		stu.setStid(Integer.parseInt(stid));
		stu.setFirstName(firstName);
		stu.setLastName(lastName);
		
		ModelAndView mv = new ModelAndView();
		mv.addObject("stu", stu);
		mv.setViewName("success");
		
		return mv;
		
		
	}
	
	 */
	
	
	
	
	
	/* 2nd approach
	 * @RequestMapping(value="/registerUser",method = RequestMethod.POST) public
	 * ModelAndView registerStudent(@RequestParam("stid") int stid ,
	 * 
	 * @RequestParam("firstName") String firstName,
	 * 
	 * @RequestParam("lastName") String lastName) {
	 * 
	 * Student stu = new Student(); stu.setStid(stid); stu.setFirstName(firstName);
	 * stu.setLastName(lastName);
	 * 
	 * 
	 * dao.register(stu);
	 * 
	 * ModelAndView mv = new ModelAndView();
	 * 
	 * mv.setViewName("success");
	 * 
	 * return mv;
	 * 
	 * 
	 * }
	 */
	
	@RequestMapping(value="/registerUser",method = RequestMethod.POST)
	public ModelAndView registerStudent(@ModelAttribute("stu") Student x)
	{
		
		/*
		 * 
		 * 1.it will take the form parameter values and bind it to Student model class properties
		 *   by creating the Student class object
		 * 2. we no need to add the object to model also
		 * 
		 * 
		 */
	
	    dao.register(x);
		
		ModelAndView mv = new ModelAndView();
		
		mv.setViewName("success");
		
		return mv;
		
		
	}
	
	
	
	

}
  

spring orm crud use case:
``````````````````````````
1.create a table in the database
   -it is optional
   
2.create a spring configuration file(springcontext.xml)
  -it contains information of SessionFactory,DataSource...
  
3.Create Student.java file
   -it is the persistent class/entity class/model class
   
4.create StudentDao.java
   -it is the dao class that uses HibernateTemplate 

5.create Test file
   -it calls methods of EmployeeDao 
   
   
Student.java:
```````````````
package com.sopra.beans;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Student {
	
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String firstName;
	private String lastName;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getFirstName() {
		return firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}
	@Override
	public String toString() {
		return "Student [id=" + id + ", firstName=" + firstName + ", lastName=" + lastName + "]";
	}
	
	

}

StudentDao.java:
````````````````

package com.sopra.dao;

import com.sopra.beans.Student;

public interface StudentDao {
	
	int saveStudent(Student student);
	

}


StudentDaoImpl.java:
`````````````````````
package com.sopra.dao;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate5.HibernateTemplate;
import org.springframework.transaction.annotation.Transactional;

import com.sopra.beans.Student;


public class StudentDaoImpl implements StudentDao {

	@Autowired
	private HibernateTemplate template;
	
	
	public HibernateTemplate getTemplate() {
		return template;
	}


	public void setTemplate(HibernateTemplate template) {
		this.template = template;
	}


	@Transactional
	public int saveStudent(Student student) {
		
		Integer result=(Integer)template.save(student);
		
		return result;
	}

}


Test.java:
```````````
package com.sopra;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.sopra.beans.Student;
import com.sopra.dao.StudentDao;

/**
 * Hello world!
 *
 */
public class App 
{
   public static void main(String[] args) {
	
	   
	   ApplicationContext context = new ClassPathXmlApplicationContext("springcontext.xml");
	   
	   StudentDao dao = (StudentDao)context.getBean("dao");
	   
	   Student stu = new Student();
	   stu.setFirstName("ram");
	   stu.setLastName("sopra");
	   
	   int x = dao.saveStudent(stu);
	   System.out.println(x + "row(s) inserted");
}
}



springcontext.xml:
```````````````````
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

     <tx:annotation-driven/>
     <context:component-scan base-package="com.sopra"></context:component-scan>

	<bean id="dao" class="com.sopra.dao.StudentDaoImpl">

		<property name="template" ref="template" />

	</bean>

	<bean id="template"
		class="org.springframework.orm.hibernate5.HibernateTemplate">

		<property name="sessionFactory" ref="mySessionFactory" />
	</bean>

	<bean id="mySessionFactory"
		class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="ds" />
		<property name="annotatedClasses">
			<list>
				<value>com.sopra.beans.Student</value>
			</list>
		</property>
		<property name="hibernateProperties">

			<props>
			    <prop key="hibernate.dialect">org.hibernate.dialect.Oracle10gDialect</prop>
                <prop key="hibernate.hbm2ddl.auto">create</prop>
                <prop key="hibernate.show_sql">true</prop>
                <prop key="hibernate.format_sql">true</prop>

			</props>

		</property>

	</bean>


	<bean id="ds"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">

		<property name="driverClassName"
			value="oracle.jdbc.driver.OracleDriver" />
		<property name="url"
			value="jdbc:oracle:thin:@localhost:1521:xe" />
		<property name="username" value="sopra" />
		<property name="password" value="sopra" />

	</bean>


    <bean class="org.springframework.orm.hibernate5.HibernateTransactionManager" name="transactionManager">
    
         <property name="sessionFactory" ref="mySessionFactory"/>
    
    </bean>



</beans>

pom.xml:
````````
    ->spring context
	->hibernate core
	->spring orm 
	

<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.sopra</groupId>
	<artifactId>spring-orm-deom</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>spring-orm-deom</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>

		<!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>5.3.10</version>
		</dependency>


		<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-core</artifactId>
			<version>5.5.7.Final</version>
		</dependency>

		<!-- https://mvnrepository.com/artifact/org.springframework/spring-orm -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>5.3.10</version>
		</dependency>


		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>

	</dependencies>
</project>

spring web mvc module java based configuration:
``````````````````````````````````````````````
note: spring vesrion : 5.3.8

spring web mvc application w.r.to java based configuration:
````````````````````````````````````````````````````````````

index.jsp:
`````````
<html>
<body>

<form action="greet">
<input type="submit" value="press to greet">

</form>
</body>
</html>


GreetController.java:
````````````````````
package com.sopra.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class GreetController {
	
	@RequestMapping("/greet")
	public ModelAndView showView()
	{
		ModelAndView mv = new ModelAndView();
		mv.setViewName("result");
		mv.addObject("res","Sopra welcomes you to Spring");
		
		return mv;
	}

}

MyConfig.java:
`````````````
package com.sopra.web;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;


@Configuration
public class MyConfig implements WebMvcConfigurer {

	
	@Bean
	public ViewResolver view()
	{
		InternalResourceViewResolver ivr = new InternalResourceViewResolver();
		ivr.setPrefix("/WEB-INF/jsps/");
		ivr.setSuffix(".jsp");
		return ivr;
	}
	
}

WebInitializer.java:
````````````````````
package com.sopra.web;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		// TODO Auto-generated method stub
		return new Class[] {MyConfig.class};
	}

	@Override
	protected String[] getServletMappings() {
		// TODO Auto-generated method stub
		return new String[] {"/"};
	}

}


result.jsp:
```````````
<%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"
    isELIgnored="false"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Insert title here</title>
</head>
<body>
 ${res}
</body>
</html>

	
	
	


