sept-12th/2023

java:
`````
java is an oo  programming langauge.

to develop the software.

what is software/application:

sunmicrosystem 

desktop/standalone application 

   -results are not sharable across the globe. 
   
distributed/intenet based application .

using java, we can develop both type of applications


 1995
 13 features 
 java is platform independent 
 
 
 windows
 
 .java(source code) -> developer 
 
   as well as compiler 
   
   java compiler -> whether programmer follows 
   syntaxes or not?
   
   
    compiler will generate .class file for your
	.java file. 
	
	
	.class file contains -> byte code.
	
	
	byte code: 
	
	 byte code cannot understanable by human beings.
	 
	 jvm -> java virtual machine
	 
	platform independent

   
steps to write the java program:


www.oralce.com 

download and install jdk in your machine
select the editor (notepad,notepad++,eclipse...)
write the java program 
save the java program (.java)-source code
compile the java program (.class)-byte code 
    -java compiler 
run/execute the java program 
    -jvm 
	
	
jdk,jre & jvm 

jdk stands for java development kit 
 which provides both dev environment and as well 
 as runtime environment.
 
jre stands for java runtime environment , name itself
is saying it provides only runtime environment
using this we can execute/run the java applications.


jvm stands for java virtual machine using this 
we can execute the java program .


	





java is case sensitive.

structure of the java program:

  class Welcome
  {
     public static void main(String[] args)
	 {
	  System.out.println("welcome to vits");   
	 }
  
  }
  








   
	 
	 
	 
	 
	 
	 
 
 .class 
 
 
 variablie initialization 
 
  
 <datatypename> <variablename> = <value>;
 
 
 
 int roll_no = 3131;
 
4 categories

integer

   byte,short,int,long
   
   
   -to store integer values.

 every datatype is maintaining their own 
 size and range.
 
 byte -> 1 byte (8 bits)
 range of byte datatype -> -128 to 127
 
 byte b = 128;
 
 
 -2^n-1 to 2^n-1 -1
 -2^7 to 2^7 -1
 
 -128 to 127
 
 byte 1 byte
 short 2 bytes
 
 int 4 bytes
 long 8 bytes
 
   

float - 4 bytes, double - 8bytes

   123.89;
   
float f = 6.7876786f;

double d = 6.776576576576567;


 char c = 'a';(2 bytes)
 
 
 
 



character


boolean 

  -To store logical values either true or false.
  
  
 boolean b = true; (not defined)
 boolean x = false;
 
 
 method:
 method is the place where we are writing the logic 
 which is used to perfrom some operation based 
 on the requirement.
 
 
 syntax:
 ```````
 
 [accessmodifier] <returntype> <methodname>([parms])
 {
    //logic 
 }
 
 define one method which gives sum of two numbers.
 
 void getSum()
 {
   System.out.println(5+7);   
 }
 
 
 define one method which returns your salary?
 
 double getSalary(){
 
   return 46000.00;
   
 }
   
 returntype and return value must be compatible
 with each other.
 
 
 
 
 define one method which takes two integer parameters
 and gives their multiplication?
 
    void getMultiplication(int x, int y){
	
	System.out.println(x*y);
	}


define one method which takes firstname and last name 
as parameters and returns their fullname?

       String getFullName(String fname,String lname)
	   {
	     return fname+lname;
	   }
	   
oops principles 

  class 
  object

  
class looks like 

 object:
 
  instance of class is known as object 
  
 whenever we create the object, then only memory 
 will be created.
 
 
 syntax to create the object:
 <classname> <objectname> = new <classname>();
 
 ex:
 
   Test1 obj = new Test1();
   
   whenever we create the object, memory will be 
   allocated for the non-static/instance variables which 
   we declared inside the class. 
   
   
 
 
 
 
 
 
 
 
 
 


 class Test1{
	  //instance variables
	 
	   int roll_no=3131;
	   String stname="vandhana";
	   
	   //static variables
	   static String collegeName="vits";
	  
	  //define  method 
	  //non-static or instance method
	  void displayStudentInfo(){
		   //instance area 
		  System.out.println("student rollno is: " + roll_no);
	      System.out.println("student name is: " + stname);
	      System.out.println("college name is: " + Test1.collegeName);
           
	 }
	 
	 
	  public static void main(String[] args)
	  {
		  //static area
		  Test1 obj = new Test1();
		  
		  System.out.println(obj.roll_no);
		  System.out.println(obj.stname);
		  
		  System.out.println(collegeName);
		  
		  System.out.println("===============");
		  //invoke the displayStudentInfo()
		  obj.displayStudentInfo();
		  
	  }
  
 }
 
 
 constructor:
 ````````````
 
 constructor is meant for initializing the object.
 
 system defined default constructor meant for 
 intializing the default values.
 
 user defined default constructor meant for 
 initializing our own values.
 
 rules:
 constructor should not return anything even void also.
 
 constructor name and class name must be same. 
 
sum(int x, int y)
{
}

sum()
{
}

Test1()
{
}

 
  class Test1{
	  int x;
	  String y;
	  
	  public  Test1(int x, String y ){
		  this.x=x;
		  this.y=y;
		 
	  }
	  
	  
	  public void displayValue()
	  {
		  System.out.println("x value is: " + x);
		  System.out.println("y value is: " + y);
	  }
	   
	  public static void main(String[] args)
	  {
		  
	      Test1 obj = new Test1(100,"rk");
		 
		  obj.displayValue();
	  }
	  
 }
 
 
 
 constructor chaining:
 
constructor calling is from top to bottom where as execution is from 
bottom to top.


public class Test2 {
	
	Test2(){
		//call current class single parametrized constructor
		this(4);
		System.out.println("iam from default constructor");
		
	}
	
	Test2(int x){
		//call current class double parameterized constructor
		this(10,"rk");
		System.out.println("iam from single parameterized constructor");
	}
	
	Test2(int x, String y)
	{
		System.out.println("iam from double parameterized constructor");
	}
	
	public static void main(String[] args) {
		
		Test2 obj1 = new Test2();
		//Test2 obj2 = new Test2(9);
		//Test2 obj3 = new Test2(7,"rk");
	}

}



java is object oriented programming language


   it follows oops principles
   
omg organization (object management group)-canadian organization 

 inheritance
 polymorphism 
 encapsulation 
 abstraction 
 
reusabiility

inheritance:


inheritance is the process of taking the properties from parent class to 
child class. 


//parent class 
 class Test1
 {
   public void sum(int x, int y)
   { 
      System.out.println("sum is: " +(x+y));
	}
 }

//child class 
 class Test2 extends Test1
 {
 
    public static void main(String[] args)
	{
	     Test2 obj = new Test2();
		 obj.sum();
	}
 }
 
 
 
 
 
 
 
 
 polymorphism:
 `````````````
 
 many forms. 
 
 compile time polymorphism
 runtime polymorphism
 
 
 using two concepts
 
  1.method overloading - compiletime polymorphism
  2.method overriding  - runtime polymorphism
  
  
  method overloading:
  
    
	  method name is same 
	  but signature is different 
	  
	  signature:
	    no.of parameters
		type of parmaeters
		order of parmaeters
		
		
 sum(int x, int y)
 {
 }
 
 sum(float x, float y)
 {
 }
 
 sum(double x, double y)
 {
 }
 
 
 sum(4,5);
 sum(5.6f,4.5f)
 sum(8.9,6.7)
 

readiblity of the program gets increased.



example:


public class Test6 {

	public void sum(int x, int y) {
		System.out.println("integer sum is: " +(x+y));
	}
	
	public void sum(float x, float y)
	{
		System.out.println("float sum is: " +(x+y));
	}
	
	public void sum(double x, double y)
	{
		System.out.println("double sum is: " +(x+y));
	}
	
	
	
	
	public static void main(String[] args) {
		
		Test6 obj;//object declaration 
		obj = new Test6();//object referencing
		
		obj.sum(4, 5);
		obj.sum(8.7f,5.6f);
		obj.sum(8.9,5.6);
	}

}








method overriding:

 method name is same
 but logic/body is different from parent class to child class.
 
 
 class Parent{
 marriage()
 {
   //logic 1
 }
 }
 
 class Child extends Parent{
 
  marriage()
  {
   //logic 2
  }
  
 }
 
 

//child class
public class Test4 extends Test3 {

	@Override
	public void sum(int x, int y)
	{
		System.out.println("substraction is: : " + (x-y));
	}
	public static void main(String[] args) {
		
		
		//case1 :valid: Test4 obj1 = new Test4();
		
		//case2: Test3 obj2 = new Test3();
		
	  Test3 obj3;
	  obj3= new Test4();
	    
	  obj3.sum(4, 5);
	    //case 4: Test4 obj4 = new Test3();
	    
	    
	    
	}
	
	
}

encapsulation:
``````````````

the process of wrapping up of variables and methods into a single unit. 
class is the best example for encapsulation.

 data hiding 
 
class Test1
{

}

class contains variables 

variables must be private
for each and every variable we require public setter methods and 
public getter methods.

setter methods -> to set the values into an object
getter methods -> to get the values from the object. 



Student.java:
`````````````
public class Student
{
	//variables
	
	private int stid;
	private String stname;
	
	public int getStid() {
		return stid;
	}
	public void setStid(int stid) {
		this.stid = stid;
	}
	public String getStname() {
		return stname;
	}
	public void setStname(String stname) {
		this.stname = stname;
	}

}

Test7.java:
````````````

public class Test7 {

	public static void main(String[] args) {
		
		Student obj = new Student();
		
		obj.setStid(100);
		
		obj.setStname("rama");
		
		System.out.println("student id is: " + obj.getStid());
		System.out.println("student name is: " + obj.getStname());
		
	}
}

abstraction:
```````````

   abstraction is the process of retrieving the essential details 
   by hiding the logic(implementation details)
   
   
   ->by using two concepts
   
   1.abstract class
   2.interface
   
   
abstract class:

   abstract class Test1{
   
     public abstract void sum(int x, int y);
	 
   }
   
   
   0 to 100%
   
   
  Test8.java:
``````````````

//abstract class where specification is available
public abstract class Test8 {
	
public abstract void sum(int x, int  y);
	

}


Test9.java:
```````````
  
//implementation class cum child class cum business logic class 
public class Test9 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("sum is: " +(x+y));

	}

}

Test10.java:
```````````

public class Test10 extends Test8 {

	@Override
	public void sum(int x, int y) {
		System.out.println("substraction is : " +(x-y));
	}

	public static void main(String[] args) {
		
		
		Test8 obj1 = new Test9();
		Test8 obj2 = new Test10();
		
		obj1.sum(2, 3);
		
		obj2.sum(2, 3);
		
		
		
		
	}
}

   
   
   
   
   
interface:
``````````
   interface contains only abstract methods 
   
  syntax:
  
     interface <interfacename>
	 {
	 
	    //constants
		//abstract methods 
	 }
   
   
   by default interface variables are public static final 
   by default interface methods are public abstract 
   
   
 Bank.java:
````````````
 
public interface Bank {

	double rateOfInterest();
}

SBI.java:
``````````

public class SBI implements Bank{

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 5.5;
	}

}


HDFC.java:
``````````

public class HDFC implements Bank {

	@Override
	public double rateOfInterest() {
		// TODO Auto-generated method stub
		return 7.5;
	}

}

Test12.java:
```````````````

//execution logic class
public class Test12 {
	
	public static void main(String[] args) {
		
		
		Bank obj = new SBI();
		Bank obj1 = new HDFC();
		
		System.out.println("SBI rate of interest is: " + obj.rateOfInterest());
		System.out.println("HDFC rate of interst is : " + obj1.rateOfInterest());
		
	}

}


 super keyword:
 
 suepr is the java reserved keyword.
 
 
  super refering parent class properties.
  
  

to refer the parent class variable 
syntax:
  super.<parentclassvariablename>
  
  
  Test3.java:
  ```````````
  //parent class
public class Test3 {

	 int x=100;
}

Test4.java:
````````````
//child class
public class Test4 extends Test3 {

	 int x = 200;
	 
	 public void display()
	 {
		 System.out.println(x);
		 System.out.println(super.x);
		 
		 
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.display();
	}

}



super at method:


   super.<parentclassmethod>();

Test3.java:
```````````
//parent class
public class Test3 {

	public void sum(int x, int y)
	{
		System.out.println("integer sum is: " + (x+y));
	}
}

Test4.java:
```````````

//child class
public class Test4 extends Test3 {

	 @Override
	 public void sum(int x, int y)
	 {
		System.out.println("integer substraction is: " +(x-y));
		
		//invoke parent class sum method using super keyword
		
		super.sum(6, 5);
	 }
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		obj.sum(3, 4);
	}

}


super at constructor level:
 
  constructor should not be inherited.
  
  writing the super() is optional to invoke parent class 
  default constructor.
  
  
  writing the super(..) is mandatory to invoke parent class 
  paramerterized constructor(s).
  
   
  Test3.java:
```````````
//parent class
public class Test3 {

	public Test3()
	{
		System.out.println(" default constructor-parent class");
	}
}

Test4.java:
```````````
  //child class
public class Test4 extends Test3 {

	public Test4()
	{
		//invoking parent class default constructor
		//super();
		System.out.println("default constructor -child class");
	}
	
	public static void main(String[] args) {

		
		Test4 obj = new Test4();
		
	}

}

   











